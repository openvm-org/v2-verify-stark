# Verifying VM STARK Proofs

## Aggregation Chain

As in v1, OpenVM v2 starts with a list of app segment proofs, which are generated by the VM during execution. App segment proofs are then aggregated by the leaf level verifier circuit, which (a) verifies each segment proof using our v2 protocol, (b) verifies inter-segment consistency, and (c) produces its own STARK proof of execution correctness. This process repeats at the internal-for-leaf level and then at the internal-recursive level. Note that the internal-recursive level verifier circuit can verify both internal-for-leaf and internal-recursive proofs. In summary:

1. **App VM** → Executes program segments, produces app segment proofs
2. **Leaf Verifier** → Aggregates and verifies app segment proofs
3. **Internal-For-Leaf Verifier** → Aggregates and verifies leaf proofs
4. **Internal-Recursive Verifier** → Aggregates and verifies internal-for-leaf and then internal-recursive proofs until one proof remains

## Public Values

The final internal-recursive proof will expose the following public values:

- `user_pv_commit`: Merkle root of the user public values exposed at the app level
- `program_commit`: Program code commitment
- `initial_pc`: Initial program counter at the start of app execution
- `final_pc`: Final program counter after app execution
- `exit_code`: Exit code after app execution
- `is_terminate`: Flag to indicate whether the program terminated or not
- `initial_root`: Merkle root of VM memory at the start of app execution
- `final_root`: Merkle root of VM memory after app execution
- `internal_flag`: Internal aggregation layer indicator (0, 1, or 2)
- `leaf_commit`, `internal_for_leaf_commit`, `internal_recursive_commit`: Cached trace commits for the leaf, internal-for-leaf, and internal-recursive verifier circuits respectively

## Verification Checks

**STARK and User Public Values Proof Verification:**

The final internal-recursive STARK proof is verified using the internal-recursive verifying key, and the user public values merkle root proof (generated by the app VM) is verified against the `final_root`.

**Baseline Artifact Checks:**

Given a fixed VM and executable, we must certain exposed public values against a set of baseline artifacts (which can be generated ahead of time given the exe and VM, app, and aggregation configs).

- `program_commit`, `initial_root`, and `initial_pc` are hash-compressed and compared against a baseline `app_exe_commit`, which is derived from the `VmConfig`, `VmExe`, `MemoryConfig`, and application `SystemParams`.
- `leaf_commit`, `internal_for_leaf_commit`, and `internal_recursive_commit` are also compared against a pre-computed baseline

**Other Public Values Validation:**

The other public values are checked for completeness.

- `exit_code` is checked to be 0 (success) and `is_terminate` is checked to be true.
- `internal_flag` is checked to be 2, i.e. the final layer must be internal-recursive

Note there is no expected value for `final_pc`, and thus it is left unchecked.
